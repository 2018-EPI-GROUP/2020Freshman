
# 栈区的使用
+ 1、先使用高地址处的空间，在使用低地址处的空间
+ 2、数组随着下标的增长，地址是由低到高变化的

# 原码、反码、补码
## 1. 原码

原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值。比如：如果是8位二进制：

[+1]原= 0000 0001

[-1]原= 1000 0001

第一位是符号位，因为第一位是符号位，所以8位二进制数的取值范围就是：（即第一位不表示值，只表示正负。）

[1111 1111 , 0111 1111]

即

[-127 , 127]
## 2. 反码

反码的表示方法是：

正数的反码是其本身；

负数的反码是在其原码的基础上，符号位不变，其余各个位取反。

[+1] = [0000 0001]原= [0000 0001]反

[-1] = [1000 0001]原= [1111 1110]反
## 3. 补码

补码的表示方法是：

正数的补码就是其本身；

负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1。(也即在反码的基础上+1)

[+1] = [0000 0001]原= [0000 0001]反= [0000 0001]补

[-1] = [1000 0001]原= [1111 1110]反= [1111 1111]补

    (-1) + (-127) = [1000 0001]原+ [1111 1111]原= [1111 1111]补+ [1000 0001]补= [1000 0000]补  
    
+ 整数分为有符号和无符号整数，有符号数中**正数原码、反码、补码**相同**负数原码、反码、补码**不同需要计算，无符号数**原码、反码、补码相同**

# char类型
+ 1、只占一个字节大小
+ 2、有符号取值为 10000000 00000000 00000000 10000000  ~  00000000 00000000 00000000 01111111（-128~127）
无符号取值为00000000 00000000 00000000 00000000  ~  00000000 00000000 00000000 11111111（0~255）

# float型数据存储
2进制浮点数V可以表示成下面的形式:

(-1)^S *M* 2^E

●(-1)^5表示符号位,当s=0. V为正数;当s=1 , V为负数。

●M表示有效数字,大于等于1.小于2.

●2^E表示指数位。

举例来说:十进制的5.0 ,写成:进制是101.0.相当于1.01x2/2.那么,按照上面V的格式.可以得出s=0，

M=1.01. E=2。

十进制的5.0,写成=进制是-101.0 ,相当于-1.01x2^2.那么，s=1 , M=1.01, E=2。

对于32位的浮点数。最高的1位是符号位s ,接着的8位是指数E ,剩下的23位为有效数字M.
**s占一个字节**
**E得加127 存进去 然后化成二进制存储  m是小数点后的二进制  比如说是011 因为M占23个bit 所以后面得补20个0  01100000000000000000000；（只针对浮点数…）**
**M占23个bit**

## 大端存储和小端存储

+ 1).大端存储：大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放。

+ 2).小端存储：小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低
## 代码判断该电脑字节序
```
#include<stdio.h>
int check()
{
	int a = 1 ;
	return *(char*)&a; 
}

int main()
{
 int ret = check(); 
 if(ret == 1)
 {
 	printf("小端\n");
 }
 else
 printf("大端\n");
}
```
