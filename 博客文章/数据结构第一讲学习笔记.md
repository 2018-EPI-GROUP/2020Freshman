# 数据结构学习笔记——第一讲 概述

已发布于CSDN

[CSDN网址](https://blog.csdn.net/weixin_39659738/article/details/113404104)

## 第一讲 概述

***clock()**：捕捉从*程序开始运行*到clock()被调用所耗费的时间，时间单位是tick，”时钟打点“。

**用法示例**：需引用<time.h>头文件

```c
#include<time.h>
clock_t start,stop;
double duration;
int main()
{
    start=clock();//计时器开始
    function();//运行的程序
    stop=clock();//计时器停止
    duration=((double)(stop-start));
}
```

<u>注意：一般情况下程序运行时间极短，故需让被测函数重复运行多次，使得测出的时间间隔充分长，最分计算平均运行时间！</u>

**算法优化举例：**

> 题目：计算x=1.1时f(x)=1+x+x^2/2+x^3/3+…+x^n/n的值

低级算法：

```c
double func1(double x)//普通算法 
{
	int i;
	double sum=1;
	for(i=1;i<101;i++)
	{
		sum+=1.0*pow(x,i)/i;
	}
	return sum;
}
```

秦九韶算法：（优化）

```c
double func2(double x)//优化：秦九韶算法 
{
	int i;
	double p=1.0/100;
	for(i=100;i>1;i--)
	{
		p=x*p+1.0/(i-1);
	}
	p=x*p+1;
	return p; 
}
```

两种算法的比较：

```c
int main()
{
	clock_t start,stop;
	double dur1,dur2;//持续时间变量名 
	start=clock();
	for(int i=0;i<10000;i++) 
	func1(1.1);
	printf("%f\n",func1(1.1));
	stop=clock();
	dur1=(double)(stop-start)/10000;
	start=clock();
	for(int i=0;i<10000;i++) 
	func2(1.1);
	printf("%f\n",func2(1.1));
	stop=clock();
	dur2=(double)(stop-start)/10000;
	printf("普通算法运行时间为：%f ticks，秦九韶算法运行时间为：%f ticks",dur1,dur2);
	return 0;
```

![image-20210129180934271](C:\Users\ZJQ\AppData\Roaming\Typora\typora-user-images\image-20210129180934271.png)

机器运算加减法的速度比乘除法的速度要快很多

最坏情况复杂度T worst(n)<=平均复杂度T ave (n)

</br>复杂度渐进表示法</br>

T(n)=O(f(n))表示存在常数C>0,n0>0，使得当n>=n0时，有T(n)<=C*f(n) //一般写最小的上界

T(n)=V(f(n))表示存在常数C>0,n0>0，使得当n>=n0时，有T(n)>=C*f(n) //一般写最大的下界

**程序员一般会绞尽脑汁想办法把O(n^2)的算法优化为O(nlogn)**

T1(n)+T2(n)=max(O(f1(n)),O(f2(n)))

T1(n)*T2(n)=O(f1(n) * f2(n))

**一个for循环的时间复杂度等于循环次数乘以循环体代码的复杂度**

**if-else结构的复杂度取决于条件判断复杂度和两个分支复杂度，*总体复杂度取三者中最大！* **

>题目：求最大子列和问题，若序列中所有整数皆为负数，则输出0
>
>给定*K*个整数组成的序列{ *N*1, *N*2, ..., *N^K* }，“连续子列”被定义为{ *N**i*, *N**i*+1, ..., *N**j* }，其中 1≤*i*≤*j*≤*K*。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。
>
>本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下：
>
>- 数据1：与样例等价，测试基本正确性；
>- 数据2：102个随机整数；
>- 数据3：103个随机整数；
>- 数据4：104个随机整数；
>- 数据5：105个随机整数；
>
>### 输入格式:
>
>输入第1行给出正整数*K* (≤100000)；第2行给出*K*个整数，其间以空格分隔。
>
>### 输出格式:
>
>在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。

低级算法：遍历所有子列，求和找最小

**复杂度：O(N^3)**

```c
nt max_part1(int a[],int n)//遍历每个子列，最低级算法：复杂度：O(N^3) 
{
	int sum=0,max=0;
	for(int i=0;i<n;i++)
	{
		for(int j=i+1;j<n;j++)
		{
			sum=0; 
			for(int k=i;k<=j;k++)
			{
				sum=sum+a[k];
			}
			if(sum>max) max=sum;
		}
	}
	return max;
}
```



中级算法：免去第三层循环，从头到尾边遍历边比较

**复杂度：O(N^2)**

```c
int max_part2(int a[],int n)//中级算法：在当前子列的基础上逐加元素，复杂度：O(N^2) 
{
	int sum=0,max=0;
	for(int i=0;i<n;i++)
	{
		sum=0;
		for(int j=i;j<n;j++)
		{
			sum=sum+a[j];
			if(sum>max) max=sum;
		}
	}
	return max;
}
```

高级算法：在线处理，按顺序推进

//在线：每输入一个数据就进行即时处理，在任何一个地方中止输入，算法都能正确给出当前的解

**复杂度：O(N)**

```c
int max_part3(int a[],int n)//高级算法：在线处理，按顺序依次推进，
//若当前和大于当前最大子列和则更新最大子列和，若当前和小于0重置当前和。复杂度：O(N)，最快，起初难理解 
{
	int sum=0,max=0;
	for(int i=0;i<n;i++)
	{
		sum=sum+a[i];
		if(sum>max) max=sum;
		else if(sum<0) sum=0;	
	}
	return max;	
} 
```

**运行结果**

![image-20210129183147596](C:\Users\ZJQ\AppData\Roaming\Typora\typora-user-images\image-20210129183147596.png)

