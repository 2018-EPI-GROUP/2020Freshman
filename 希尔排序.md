# 希尔排序

### 1、排序介绍

**a、需求：**

排序前：{9,1,2,5,7,4,8,6,3,5}

排序后：{1,2,3,4,5,5,6,7,8,9}

**b、排序原理：**

1、选定一个增长量h,按照增长量h作为数据分组的依据，对数据进行分组；

2、对分好组的每一组数据完成插入排序；

3、减小增长量，最小减为1，重复第2部和第三部操作。

**注意：**

**增量一般选取方法：**

第一次的增量为：**数组的长度 / 2，此后每次增量为为上一次增量的一半，直到增量缩小到1**

![1611740714215](C:\Users\29455\AppData\Roaming\Typora\typora-user-images\1611740714215.png)

**代码：**

```java
public static void main(String[] args) {
        int[] a = {9,1,2,5,7,4,8,6,3,5};
        int l, j, temp;
        for(l = a.length / 2; l >= 1; l /= 2){
            for(int i = l; i < a.length; i++){
                temp = a[i];
                for(j = i - l; j >= 0&&a[j] > temp; j -= l){
                    a[j + l] = a[j];
                }
                a[j + l] = temp;
            }
        }
        System.out.println(Arrays.toString(a));
    }

运行结果：
    [1, 2, 3, 4, 5, 5, 6, 7, 8, 9]
```

### 2、API设计

**a、API设计需求**

| 类名     | Shell                                                        |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Shell()：创建Shell对象                                       |
| 成员方法 | 1、public static void sort(Comparable[] a):对数组内的元素进行排序 |
|          | 2、private static boolean greater(Comparable a, Comparable b)判断a和b的大小 |
|          | 3、private static void exch(Comparable[] a, int i, int j)：交换a数组中，索引i和j处的值 |

**b、API实现**

```java
public class Shell {

    public static void sort(Comparable[] a){
        int i, j;
        Comparable temp;
        for(int l = a.length; l >= 1; l /= 2){
            for(i = l; i < a.length; i++){
                temp = a[i];
                for(j = i - l; j >= 0&&greater(a[j], temp); j -= l){
                    exch(a, j, j + l);
                }
                a[j + l] = temp;
            }
        }
    }

    private static boolean greater(Comparable a, Comparable b){
        return a.compareTo(b) > 0;
    }

    private static void exch(Comparable[] a, int i, int j){
        a[j] = a[i];
    }
```

**测试类：**

```java
public class Test {

    public static void main(String[] args) {
        Integer[] a = {9,1,2,5,7,4,8,6,3,5};
        Shell.sort(a);
        System.out.println(Arrays.toString(a));
        Double[] b = {1.0,2.5,0.3,6.4,0.9,1.1};
        Shell.sort(b);
        System.out.println(Arrays.toString(b));
    }
}

运行结果：
    [1, 2, 3, 4, 5, 5, 6, 7, 8, 9]
	[0.3, 0.9, 1.0, 1.1, 2.5, 6.4]
```



### 时间复杂度分析

希尔排序的增长量是不确定的，因此希尔排序是不稳定的排序方法，它的时间复杂度难以计算，可以使用事后分析法对希尔排序和插入排序做性能分析。

在程序开始执行时，获取时间，结束时，在获取时间，两者差值，即为运行时间，进行对比；

