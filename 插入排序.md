# 插入排序

**插入排序是一种简单直观且稳定的排序算法**。

### 插入排序概述：

**需求：**

​		排序前：{4,3,2,10,12,1,5,6}

​		排序后：{1,2,3,4,5,6,10,12}

**排序原理：**

**1、把所有元素分为两组，已经排序的和未知排序的；**

**2、找到未排序的组中的第一个元素，向已经排序的组中进行插入**

**3、倒叙遍历已经排序的元素，依次和带插入的元素进行比较，直到找到一个元素小于等于带插入元素，那么就把待插入元素放到这个位置，其他的元素后移一位；**

**图解：**

![1611315832141](C:\Users\29455\AppData\Roaming\Typora\typora-user-images\1611315832141.png)

**代码实现：**

```java
public static void main(String[] args) {
        int[] a = {4,3,2,10,12,1,5,6};
        int i ,j, temp;
        for(i = 1; i < a.length; i++){
            temp = a[i];
            for(j = i - 1; j >= 0&&temp < a[j]; j--){
                    a[j + 1] = a[j];
            }
            a[j + 1] = temp;
        }
        for(int x : a){
            System.out.print(x + " ");
        }
    }
运行结果
    1 2 3 4 5 6 10 12 
```

### **插入排序API实现**

**插入排序API设计**

| 类名     | Inserttion                                                   |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Insertion():创建对象Insertion对象                            |
| 成员方法 | 1、public  static  void  sort(Comparable[]  a)：对数组内的元素进行排序 |
|          | 2、private  static  boolean  greater(Comparable  a,  Comparable  b):判断a和b的大小 |
|          | 3、private  static  void  exch(Comparable[]  a,  int  i,  int  j); 交换a数组中，索引i和索引j处的值。 |

**b、插入排序API代码实现**

```java
public static void sort(Comparable[] a){
        for(int i = 1; i < a.length; i++){
            Comparable temp = a[i];
            int j;
            for(j = i - 1; j >= 0; j--){
                if(greater(a[j], temp)){
                    exch(a, j + 1, j);
                }else{
                    break;
                }
            }
            a[j + 1] = temp;
        }
    }

    private static boolean greater(Comparable a, Comparable b){
        return a.compareTo(b) > 0;
    }

    private static void exch(Comparable[] a, int i, int j){
        a[i] = a[j];
    }
```

**测试类：**

```java
public static void main(String[] args) {
        Integer[] a = {4,3,2,10,12,1,5,6};
        Insertion.sort(a);
        System.out.println(Arrays.toString(a));
    }
运行结果：
    [1, 2, 3, 4, 5, 6, 10, 12]
```



### 时间复杂度分析

插入排序使用双层for循环，其中内层循环的循环体是真正完成排序的代码，所以分析插入排序的时间复杂度，主要分析内层循环体的执行次数即可

最坏情况也就是待排序的数组元素为{12,10,6,5,4,3,2,1}，那么：

比较的次数为：(n - 1) + (n - 2) + ...... + 2 + 1 = n * ( n - 1) / 2; 

交换的次数为：(n - 1) + (n - 2) + ...... + 2 + 1 = n * ( n - 1) / 2;

**程序总次数：n^2 - n**

根据大O推导法则，推出插入排序的**时间复杂度为O(n^2)**

