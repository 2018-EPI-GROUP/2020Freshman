常见的鼠标事件
click：单击事件
dblclick：双击事件
mousedown：按下鼠标键时触发
mouseup：释放按下的鼠标键时触发
mousemove：鼠标移动事件
mouseover：移入事件
mouseout：移出事件
mouseenter：移入事件
mouseleave：移出事件
contextmenu：右键事件

●mouseover 鼠标经过自身盒子会触发,经过子盒子还会触发。mouseenter 只会经过自身盒子触发，之所以这样,就是因为mouseenter不会冒泡
●跟mouseenter搭配鼠标离开mouseleave 同样不会冒泡

键盘事件
1.keydown()事件
当按钮被按下时，发生 keydown 事件。

2.keypress()事件（不常用）
keypress 当按钮被按下时，会发生该事件，我们可以理解为按下并抬起同一个按键，不识别功能键，例如ctrl等

3.keyup事件
keyup 事件会在按键释放时触发，也就是你按下键盘起来后的事件
三个事件的执行顺序是keydown–keypress–keyup

本地存储
本地存储特性
1、数据存储在用户浏览器中
2、设置、读取方便、甚页面刷新不秩数据
3、容量较大, sessionStorage约5M、localStorage约20M4、只能存储字符串,可以将对象lSON.stringify(编码后存储“

1. window.sessionStorage
1、生命周期为关闭浏览器窗口
2、在同一个窗口(页面)下数据可以共享3.以键值对的形式存储使用
存储数据:
sessionStorage.setltem(key, value)
获取数据:
sessionStorage.getltem(key)
删除数据:
sessionStorage.removeltem(key)
删除所有数据:
sessionStorage.clear()

2. window.localStorage
1.生命周期永久生效,除非手动删除否则关闭页面也会存在
2、可以多窗口(同一浏览器可以共享)
3.以键值对的形式存储使用
存储数据:
localStorage.setltem(key, value)
获取数据:
localStorage.getltem(key)
删除数据:
localstorage.removeltem(key)
删除所有数据:
localStorage.clear()
在这里插入图片描述

节流阀
防止轮播图按钮连续点击造成播放过快。
节流阀目的:当上一一个函数动画内容执行完毕,再去执行下一个函数动画,让事件无法连续触发。核心实现思路:利用回调函数,添加一个量来控制,锁住函数和解锁函数。
开始设置一个变量 var flag= true;lf(flag) {flag = false; do something}
关闭水龙头
利用回调函数动画执行完毕，flag= true打开水龙头

触屏事件概述
移动端浏览器兼容性较好,我们不需要考虑以前JS的兼容性问题,可以放心的使用原生JS书写效果,但是移动端也有自己独特的地方。比如触屏事件touch (也称触摸事件) , Android和IOS都有。
touch对象代表-一个触摸点。 触摸点可能是一根手指,也可能是一根触摸笔。 触屏事件可响应用户手指(或触控笔)对屏幕或者触控板操作。
常见的触屏事件如下:

touchstart
手指触摸到一个DOM元素时触发

touchmove
手指在一个DOM元素上滑动时触发

touchend
手指从一个DOM元素上移开时触发

触摸事件对象( TouchEvent )
TouchEvent是一类描述手指在触摸平面(触摸屏、触摸板等)的状态变化的事件。这类事件用于描述一个或多个触点,使开发者可以检测触点的移动,触点的增加和减少, 等等
touchstart、touchmove、 touchend 三个事件都会各自有事件对象。
触摸事件对象重点我们看三个常见对象列表:

这是事件对象！（e)
touches
正在触摸屏幕的所有手指的一个列表

targetTouches
正在触摸当前DOM元素上的手指的一个列表

changedTouches
手指状态发生了改变的列表，从无到有， 从有到无变化

click延时解决方案
移动端click事件会有300ms的延时,原因是移动端屏幕双击会缩放(double tap to zoom)页面。
解决方案:
1.GitHub官网地址: https://github.com/ftlabs/fastclick（优）
原理: 在检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click事件，并把浏览器在300ms之后真正的click事件阻止掉

2：禁用缩放
当HTML文档头部包含如下meta标签时：

<meta name="viewport" content="user-scalable=no">
<meta name="viewport" content="initial-scale=1,maximum-scale=1”>
缺点：网页无法缩放

3. 更改默认视口宽度
缺点：需要浏览器的支持

移动端常用开发插件
Swiper中文官网地址: https://www.swiper.com.cn/(轮播大法好)
superslide : http://www.superslide2.com
iscroll : https://github.com/cubiq/iscroll

轮播图
功能需求:
1.鼠标经过轮播图模块,左右按钮显示,离开隐藏左右按钮。

2.点击右侧按钮一 次,图片往左播放-张,以此类推，左侧按钮同理。

3.图片播放的同时,下面小圆圈模块跟随一起变化。

4.点击小圆圈 ,可以播放相应图片。

5.鼠标不经过轮播图 ,轮播图也会自动播放图片。

6.鼠标经过,轮播图模块，自动播放停止。

1.
①动态生成小圆圈

②核心思路:小圆圈的个数要跟图片张数-致

③所以首先先得到ul里面图片的张数(图片放入i里面，所以就是Ii的个数)④利用循环动态生成小圆圈(这个小圆圈要放入ol里 面)

⑤创建节点createElement(Ti")

⑥插入节点ol. appendChild(li)

2.
①点击右侧按钮一次,就让图片滚动一张。

②声明一个变量num，点击一次， 自增1， 让这个变量乘以图片宽度，就是ul的滚动距离。③图片无缝滚动原理

④把ul第一个1i复制-份，放到ul的最后面

⑤当图片滚动到克隆的最后一张图片时， 让ul 快速的、不做动画的跳到最左侧: left 为0

3.
①克隆第一张图片
②克隆ul 第一个icloneNode()加true 深克隆复制里面的子节点false 浅克隆③添加到ul最后面appendChild

4.
①自动播放功能，

②添加一个定时器

③自动播放轮播图，实际就类似于点击了右侧按钮

④此时我们使用手动调用右侧按钮点击事件arrow_ r.click()

代码
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<style>
    *{
        margin: 0px;
        padding: 0px;
        list-style: none;
        text-decoration: none;
    }
   
    .focus{
        width: 600px;
        height: 500px;
        overflow: hidden;
        position: relative;
        margin:0 auto ;    
        }
    .list{
        width:4000px;
        position: absolute;
        top:0;
        left: 0;
    }
    .list li{
        float: left;
    }
    .list li img{
        width: 600px;
        height: 400px;
    }
    .btn{
        width: 50px;
        height: 80px;
       display: none;  
       z-index: 2;
    }
    #gonext{
        right: 0px;
        top: 150px;
        position: absolute;
    }
    #gopre{
        left: 0px;
        top: 150px;
        position: absolute;
    }
    .pointlist li{
        width: 15px;
        height: 15px;
        border-radius: 100%;
        border: 3px solid white;
        float: left;
        margin-left: 10px;
    }
    .pointlist{
        position: absolute;
       left: 660px;
       bottom: 330px;
        z-index: 3;  
        cursor: pointer;
    }
    .current{
        width: 15px;
        height: 15px;
        border-radius: 100%;
        border: 3px solid white;
        float: left;
        margin-left: 10px;
        background-color: orange;

    }
</style>
<body>
<div class="warp">
    <div class="focus">
        <ul class="list">
            <li ><a href="#"><img src="./img/1.jpg" alt=""></a></li>
            <li><a href="#"><img src="./img/2.jpeg" alt=""></a></li>
            <li><a href="#"><img src="./img/3.jpg" alt=""></a></li>
            <li><a href="#"><img src="./img/4.jpg" alt=""></a></li>
            <li><a href="#"><img src="./img/5.jpg" alt=""></a></li>
        </ul>
        <button class="btn" id="gopre">
            < </button>
        <button class="btn" id="gonext">></button>
    </div>
    
</div>
<ul class="pointlist">
</ul>
<!-- animate必须在a的上方 -->
<script src="./js/animate.js"></script>
<script src="./js/a.js"></script>
</body>
 
</html>
a.js
window.addEventListener("load", function () {
    var nextbtn = document.querySelector("#gonext");
    var prebtn = document.querySelector("#gopre");
    var focus = document.querySelector(".focus");
    focus.addEventListener("mouseenter", function () {
        nextbtn.style.display = "block";
        prebtn.style.display = "block";
        clearInterval(timer);
    });
    focus.addEventListener("mouseleave", function () {
        nextbtn.style.display = "none";
        prebtn.style.display = "none";
        timer = setInterval(function () {
            nextbtn.click();
        },2000)
            
        
    });
    //动态生成小圆圈 有几张图片就产生多少小圆点
var lists = document.querySelector("ul");
    var pointlist = document.querySelector(".pointlist");
    var imgwidth = focus.offsetWidth;
    for (var i = 0; i < lists.children.length; i++) {
        //创建一个小li
        var li = document.createElement("li");
        //给每个li设置自定义属性
        li.setAttribute("index", i);
        //把li插入到pointlist
        pointlist.appendChild(li);
        //排他思想让点击的li设置current类名，要在创建li的for循环里写
        li.addEventListener("click", function () {
            for (var i = 0; i < pointlist.children.length; i++) {
                pointlist.children[i].className = " ";
            }
            this.className = "current";
            //点击小圆圈移动ul
            //ul移动距离是当前索引号乘以图片的宽度 注意向左是负值
            //先获取当前li的索引号
            var index = this.getAttribute("index");
            //当我们点击li后需把当前索引给num;
            num = index;
             //当我们点击li后需把当前索引给circle;
            circle = index;
            animate(lists, -index * imgwidth);
        });
    }
    //把第一个小li设置current类名变白
    pointlist.children[0].className = "current";
    //点击按钮切换(无缝轮播)
    //克隆第一张图片放到ul最后面
    var first = lists.children[0].cloneNode(true);
    lists.appendChild(first);
    var num = 0;
    var circle = 0;
    nextbtn.addEventListener("click", function () {
              //如果到最后一张图片，让它快速跳到第一张
        if (num == lists.children.length-1) {
            lists.style.left = 0 + "px"
            num = 0;
        }
        num++;
            animate(lists, -num * imgwidth, function () {
        });
        //声明一个变量控制小圆圈的播放
        circle++;
        if (circle == lists.children.length-1) {
            circle =0;
        }
      change()
    })
    prebtn.addEventListener("click", function () {
        //如果到第一张图片，让它快速跳到最后一张
        if (num == 0) {
            lists.style.left =-(lists.children.length-1)*imgwidth  + "px"
            num = lists.children.length-1;
        }
        num--;
        animate(lists, -num * imgwidth);
        //声明一个变量控制小圆圈的播放
        circle--;
        if (circle<0) {
            circle =pointlist.children.length-1;
        }
        change();
    })
    function change() {
        for (var i = 0; i < pointlist.children.length; i++){
            pointlist.children[i].className = "";
            pointlist.children[circle].className = "current";
        }
    }
    //自动播放
    var timer = setInterval(function () {
        //手动调用点击事件
        nextbtn.click();
    },2000)
});
   
封装好的动画函数animate（)
//缓动动画就是让每次移动的距离减小
//移动距离为（目标值-现在的位置）/10作为步长
function animate(obj,target,callback) {
    //清除之前的定时器
    clearInterval(obj.timer);
    obj.timer = setInterval(function () {
        //步长写在函数里
        var step = (target - obj.offsetLeft) / 10;
        step = step > 0 ? Math.ceil(step) : Math.floor(step);
        if (obj.offsetLeft ==target) {
            //停止动画
            clearInterval(obj.timer);
        }
        obj.style.left = obj.offsetLeft + step + "px";
    }, 15);
    if (callback) {
        callback()
    }

    
}
拖动盒子案例
PC端
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .box {
            width: 300px;
            height: 300px;
            background-color: pink;
            cursor: move;
            position: fixed;

        }
    </style>
</head>

<body>
    <div class="box"></div>

</body>
<script>
    var box = document.querySelector(".box");
    //拖拽效果由三个事件组成(onmousedown,onmousemove,onmouseup)
    box.addEventListener("mousedown", function (e) {
        //获取鼠标在盒子内的坐标
        var x = e.pageX - box.offsetLeft;
        var y = e.pageY - box.offsetTop;
        console.log(x);
        console.log(y);
        //onmousedown要写在onclick的函数里
        document.addEventListener("mousemove", move);
        function move(e) {
            //得到盒子到浏览器的距离,这里不能用offset，因为offset不能赋值
            box.style.left = e.pageX - x + "px";
            box.style.top = e.pageY - y + "px";
        }
        document.addEventListener("mouseup", function () {
            document.removeEventListener("mousemove", move)
        })

    })
</script>

</html>
移动端
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .box{
            width: 100px;
            height: 100px;
            background-color: pink;
            position: absolute;
            top:0;
            left: 0;
        }
    </style>
</head>
<body>
    <div class="box"></div>
    
</body>
<script>
    var box=document.querySelector(".box");
    //获取开始盒子坐标
    var x=0;
    var y=0;
    //获取开始手指坐标
    var startx=0;
    var starty=0;
    box.addEventListener("touchstart",function(e){
        //获取手指与盒子触摸时的坐标
        startx=e.targetTouches[0].pageX;
        starty=e.targetTouches[0].pageY;
        x=this.offsetLeft;
        y=this.offsetTop;
    });
    box.addEventListener("touchmove",function(e){
        //盒子移动距离=盒子当前距离加上手指移动的距离
        console.log(startx);
        this.style.left=x+e.targetTouches[0].pageX-startx+"px";
        this.style.top=y+e.targetTouches[0].pageY-startx+"px";
        //注意:手指移动也会触发滚动屏幕所以这里要阻止默认的屏幕滚动
        e.preventDefault();
    })
</script>
</html>
jQuery
jQuery 的入口函数
$ (function () {
… //此处是页面DOM加载完成的入口}) ;
1.等着DOM结构渲染完毕即可执行内部代码,不必等到所有外部资源加载完成, jQuery帮我们完成了封装。
2.相当于原生js中的DOMContentLoaded.
3.不同于原生js中的load事件是等页面文档、外部的js文件、Css文件、图片加载完毕才执行内部代码。

jQuery 对象和DOM对象
DOM对象与jQuery对象之间是可以相互转换的。
因为原生js比jQuery大,原生的一些属性和方法jQuery没有给我们封装.要想使用这些属性和方法需要把jQuery对象转换为DOM对象才能使用。
1. DOM对象转换为jQuery对象: $(DOM对象)
$(“div”)

2. jQuery对象转换为DOM对象(两种方式)
$('div") [index] index是索引号
$('div") .get(index) index 是索引号

jQuery 基础选择器
原生JS获取元素方式很多,很杂,而且兼容性情况不-致,因此jQuery给我们做了封装,使获取元素统标准。
$( "选择器”) // 里面选择器直接写CSS选择器即可,但是要加引号

名称 .用法 描述.
ID选择器 $("#id") 获取指定ID的元素

全选选择器 $(’*’) 匹配所有元素

类选择器 $(".class") 获取同一类class的元素

标签选择器 $(“div”) 获取同一类标签的所有元素

并集选择器 $(“div,p,li”) 选取多个元素

子代选择器 $(“ul>li”) 使用>号，荻取亲儿子层级的元素;注意,并不会获取孙子层级的元素

后代选择器 $(“ul li”) 使用空格，代表后代选择的器，荻取ul下的所有li元素，包括孙子等

隐式迭代(重要)
遍历内部DOM元素(伪数组形式存储)的过程就叫做隐式迭代。
简单理解:给匹配到的所有元素进行循环遍历,执行相应的方法,而不用我们再进行循环,简化我们的操作,方便我们调用。

<script>
        $(function(){
            // 1.隐式迭代给所有的按钮都绑定了点击事件
            $("button").click(function(){
                 // 2.当前的元素变化背景颜色
                 $(this).css("backgroundColor","pink");
                    // 3.其余的兄弟去掉背景颜色隐式迭代
                    $(this).siblings().css("backgroundColor","");
            })
        })
     
        
    </script>
如图，这样不用再for循环给每个li绑定事件，大大节省代码量

链式编程
链式编程是为了节省代码量, 看起来更优雅。

$(this).css(’ color’, ‘red").sibling.css("color’,");

使用链式编程一定注意是哪个对象执行样式

jQuery筛选方法(重点)
名称 .用法 描述.
parent() $(“1i”). parent(); 查找父级

children(selector) $(“u1”).children(“li”) ul>li最近一级(亲儿子)

eq(index) $(“li”).eq(2); 相当于第三个li,index从0开始

siblings(selector) $(".first").siblings(“li”); 查找兄弟节点，不包括自己本身

jQuery样式操作
操作css方法
jQuery可以使用CSS方法来修改简单元素样式;也可以操作类,修改多个样式。
1.参数只写属性名,则是返回属性值
$(this,css(“color”);

2.参数是属性名,属性值,逗号分隔, 是设置-组样式,属性必须加引号,值如果是数字可以不用跟单位和引号$(this,css(“color”, “red”);

3.参数可以是对象形式,方便设置多组样式。属性名和属性值用冒号隔开，属性可以不用加引号,$(this).css({ “color”.“white’ ,“font size”:” 20px"});

设置类样式方法
作用等同于以前的classList ,可以操作类样式，注意操作类里面的参数不要加点。
1.添加类
$( “div” ).addClass(“current”);

2.移除类
$( “div” ).removeClass("current’);

3.切换类
$( “div” ).toggleClass( ‘current’);

类操作与className区别原生JS中className会覆盖元素原先里面的类名。
jQuery里面类操作只是对指定类进行操作,不影响原先的类名,增加类名时类名1 类名2同时存在

jQuery效果
jQuery给我们封装了很多动画效果,最为常见的如下:

显示隐藏
show();显示
hide();隐藏
toggle();切换
滑动
sildeDown();下滑
sildeUp();上滑
slidetoggle();
淡入淡出
fadeln()
fadeOut()
fadeToggle()
fadeTo()

用法都一样
例：
1.显示语法规范
show ([speed, [easing], [fn]])
2.显示参数
(1 )参数都可以省略,无动画直接显示。
(2) speed :三种预定速度之一的字符串( “slow” ，“normal” , or “fast” )或表示动画时长的毫秒数值(如: 1000)。
(3) easing : (Optional)用来指定切换效果,默认是"swing” , 可用参数"Iinear" 。
(4) fn:回调函数,在动画完成时执行的函数,每个元素执行一次。

事件切換.
hover([over]，[out])

( 1 ) over:鼠棕移到元素上要触岌的凾数(相当于mouseenter )
(2) out:鼠棕移出元素要触竣的凾数(相当于mouseleave )

动画队列及其停止排队方法
1.动画或效果队列
动画或者效果一旦触发就会执行 , 如果多次触发,就造成多个动画或者效果排队执行。

2.停止排队stop()

(1 ) stop()方法用于停止动画或效果。
(2)注意: stop() 写到动画或者效果的前面,相当于停止结束上一次的动画。

自定义动画animate
1.语法
animate (params , [speed], [easing], [fn] )
2.参数
( 1 ) params:想要更改的样式属性,以对象形式传递,必须写。 属性名可以不用带引号,如果是复合属性则需要采取驼峰命名法borderLeft.其余参数都可以省略。
(2 ) speed:三种预定速度之一-的字符串( “slow” , “normal” , or “fast” )或表示动画时长的毫秒数值(如: 1000)。
(3 ) easing : (Optional)用来指定切换效果,默认是"swing” , 可用参数"linear" 。
(4) fn:回调函数,在动画完成时执行的函数,每个元素执行一次。

jQuery属性操作
1.设置或获取元素固有属性值prop()
所谓元素固有属性就元素本身自带的属性,比如 a 元素里面的href , 比如元素里面的type.
1.获取属性语法
prop("属性’)

2.设置属性语法
prop(“属性”, “属性值”)

2.设置或获取元素自定义属性值attr()
用户自己给元素添加的属性,我们称为自定义属性。比如给div添加index=“1” 。
1.获取属性语法
attr(“属性”) // 类似原生getAttribute(）

2.设置属性语法
attr(“属性”, “属性值”) // 类似原生setAttribute(）
该方法也可以获取H5自定义属性

jQuery内容文本值
主要针对元素的内容还有表单的值操作。
1.普通元素内容html() (相当于原生inner HTML)

html()//获取元素的内容

html(“内容”) // 设置元素的内容

2.普通元素文本内容text() (相当与原生 innerText)

parents( '选择器’) 可以返回指定祖先元素(挺好用的)
jQuery属性操作
遍历元素
$ (“div”) .each (function (index, domEle) { xxx; } )

each()方法遍历匹配的毎一个元素。 要用DOM处理。
2.里面的回凋凾数有2个参数: index 是毎个元素的索引号demEle是毎个DOM元素対象,不是jquery対象
3.所以要想使用jquery方法,需要給这个dom元素转换为jquery対象$(domEle)
jQuery事件処理
事件赴理on()绑定事件

on（）方法在匹配元素上郷定一个或多个事件的事件赴理函数語法:

element . on (events, [selector], fn)

events:一个或多 个用空格分隔的事件型, 如" click’ '或"keydown"。2. selector:元素的子元素选择器。

fn:回凋凾数即郷定在元素身上的监听函数。

on（）方法优势1:
可以郷定多个事件,多个赴理事件处理程序.
$(div") .on({
mouseover: function(){},
mouseout: function() {},
click: function() {}
});
on（）方法优势2 :
可以事件委派操作。事件委派的定义就是,把原来加给子元素身上的事件绑定在父元素身上,就是把事件委派给父元素。
$(‘ul’) .on(‘click’, ‘li’, function() {alert(‘hello world!’);}) ;
on(）方法优势3 :
动态创建的元素, click( ）没有办法绑定事件，on（)可以给动态生成的元素绑定事件
事件处理off()解绑事件
off()方法可以移除通过on(方法添加的事件处理程序。
$(“p”) .off() //解绑p元素所有事件处理程序

$(“p”) .off( “click”) // 解绑p元素上面的点击事件后面的foo是侦听函数名
$(“ul”) .off(“click”, “1i”); // 解绑事件委托
如果有的事件只想触发一次，可以使用one(来绑定事件。

jQuery 尺寸
语法 用法
width() / height() 取得匹配元素宽度和高度值只算width / height

innerWidth(/ innerHieght() 取得匹配元素宽度和高度值包含padding

outerWidth() / outerHeight() 取得匹配元素宽度和高度值包含padding、border

outerWidth(true) / outerHeight(true) 取得匹配元素宽度和高度值包含padding、borde、 margin
●以上参数为空,则是获取相应值,返回的是数字型。
●如果参数为数字,则是修改相应值。
●参数可以不必写单位。

jQuery 位置
位置主要有三个: offset（）、 position()、 scrollTop（）/scrollLeft（）

offset()设置或获取元素偏移
①offset() 方法设置或返回被选元素相对于文档的偏移坐标,跟父级没有关系。
②该方法有2个属性left、top. offet0.top 用于获取距离文档顶部的距离, offset0.left用于获取距离文档左侧的距离。
③可以设置元素的偏移: offet({ top: 10, left: 30 });

JavaScript面向对象
类constructor构造函数
constructor()方法是类的构造函数(默认方法) ,用于传递参数返回实例対象,通过new命令生成対象实例吋自动凋用该方法。如果没有显示定义，类内部会自动给我们创建一个constructor（）；
创建类：

 //(1)通过class 关键字创建类，类名我们还是习惯性定义首字母大写
        //(2)类里面有个constructor函数，可以接受传递过来的参数,同时返回实例对象
        /* (3) constructor 函数只要new生成实例时,就会自动调用这个函数，如果我们不写这个函数,类
        也会自动生成这个函数 */
        class Star{
            constructor(uname,age){
                this.uname=uname;
                this.age=age;
            }
        }
      //(4) 生成实例new不能省略
/* (5)最后注意语法规范，创建类类名后面不要加小括号生成实例类名后面加小括号，构造函数不需
要加function */
        var ldh=new Star("刘德华",19);
        var zxy=new Star("张学友",18);
        console.log(ldh);
        console.log(zxy);
类的继承

class Father {
            say() {
                console.log("我是爸爸");
            }
        }
        class Son extends Father{//这样子类就继承了父类的属性和方法
            say(){
                super.say();//super调用了父类的方法
                console.log("我是儿子");
            }
        }
        var sons=new Son();
        sons.say();
//1.継承中，如果实例化子类输出一个方法，先看子类有没有这个方法，如果有就先执行子类的
//2.継承中,如果子类里面没有,就去査找父类有没有这个方法,如果有，就执行父类的这个方法(就近原则)
//super关键字用于访问和调用对象父类上的函数。可以调用父类的构造函数,也可以调用父类的普通函数。
super关键字用于访问和调用父类上的函数，可以调用父类的构造函数，也可以调用父类的普通函数
例：super调用父类的构造函数

class Father {
            constructor(x,y){
                this.x=x;
                this.y=y;
            }
            sum1(){
                  console.log(this.x+this.y);
                }
        }
        class Son extends Father{
            constructor(x,y){
                   //利用super调用父类的构造函数而且必须在子类this之前调用
                   super(x,y)
                this.x=x;
                this.y=y;
            }
            sum2(){
                console.log(this.x-this.y);
            }
           
        }
        var sons=new Son(5,3);
        sons.sum1();
        sons.sum2();
利用super调用父类的构造函数而且必须在子类this之前

this指向问题
var that;
        class Star{
            constructor(uname,age){
                // constructor里面的this指向的是创建的实例对象
                that=this;
                console.log(this);
                this.uname=uname;
                this.age=age;
                this.btn=document.querySelector("button");
                this.btn.onclick=this.sing;
            }
            sing(){
                //因为sing被btn调用了，所以这个this指向btn
                console.log(this);
                console.log(that.uname);
            }
            dance(){
                //这个this被son调用了，所以this指向实例对象son
                console.log(this);
            }
        }
        var son=new Star("刘德华");
        son.dance();
        //// 1.在ES6中类没有変量提升，所以必須先定义类，才能通过类实例化对象
        //2.类里面的共有的属性和方法一定要加this使用.
利用构造函数创建对象
回忆一下以前创建对象的方式
1.利用对象字面量创建对象

 //利用对象字面量创建对象
        var obj = {
            name: "张三丰",
            age: 18,
            sayhi: function () {
                console.log("大家好");
            }
        }

        console.log(obj.age);
        console.log(obj.name);
        obj.sayhi()
2.利用new Object创建对象

//利用new Object创建对象
        //每个属性和方法要加分号
        var obj = new Object();
        obj.name = "张三丰";
        obj.age = 18;
        obj.sayhi = function () {
            console.log("sayhi");

        }
        console.log(obj.name);
        console.log(obj.age);
        obj.sayhi()
构造函数来创建对象
 //构造函数来创建对象
        function Star(uname, age, sex) {
            this.name = uname;
            this.age = age;
            this.sex = sex;
            this.sing = function (sang) {
                console.log(sang);
            }

        }
        var ldh = new Star("刘德华", 18, "男");//引用函数
        console.log(ldh.name);
        console.log(ldh["sex"]);
        ldh.sing("冰雨");
        var zxy = new Star("张学友", 19, "男");//引用函数
        console.log(zxy.name);
        console.log(zxy.age);
        zxy.sing("李香兰");
构造函数和原型
构造函数是一种特殊的函数,主要用来初始化对象,即为对象成员变量赋初始值,它总与new 一起使用。我们可以把对象中一些公共的属性和方法抽取出来 ,然后封装到这个函数里面。

new在执行时会做四件事情:

①在内存中创建一个新的空对象、

②让this指向这个新的对象。

③执行构造函数里面的代码,给这个新对象添加属性和方法。

④返回这个新对象(所以构造函数里面不需要retum )。

静态成员和实例成员
JavaScript的构造函数中可以添加一些成员,可以在构造函数本身上添加,也可以在构造函数内部的this.上添加。通过这两种方式添加的成员,就分别称为静态成员和实例成员。

●静态成员 :在构造函数本上添的成员称为静态成员,只能由构造函数本身来访问（Star.sex=“男”）
●实例成员 :在构造函数内部创建的对象成员称为实例成员,只能由实例化的对象来访问(在构造函数内部由this添加)

构造函数的问题:
构造函数方法很好用,但是存在浪费内存的问题。
故引入原型：

构造函数原型prototype
构造函数通过原型分配的函数是所有对象所共享的。

JavaScript规定,每一个构造函数都有 一个prototype属性,指向另一个对象。意这个prototype就是一个对象,这个对象的所有属性和方法,都会被构造函数所拥有。

我们可以把那些不变的方法,直接定义在prototype对象上,这样所有对象的实例就可以共享这些方法。

1.原型是什么?
一个对象,我们也称为prototype为原型对象。

2.原型的作用是什么?
共享方法。

function Star(name,age){
            this.name=name;
            this.age=age;

        }
        Star.prototype.sing=function(){
            console.log("我会唱歌");
        }
        var ldh=new Star("刘德华",18);
        var zxy=new Star("张学友",19);
        console.log(ldh.sing()===zxy.sing());//true
对象原型__proto__
对象都会有一个属性__proto__ 指向构造函数的 prototype原型对象,之所以我们对象可以使用构造函数prototype原型对象的属性和方法,就是因为对象有__proto__原型的存在。

●__proto__对象原型和原型对象prototype是等价的

 function Star(name,age){
            this.name=name;
            this.age=age;

        }
        Star.prototype.sing=function(){
            console.log("我会唱歌");
        }
        var ldh=new Star("刘德华",18);
        var zxy=new Star("张学友",19);
        console.log(ldh);//对象身上系统自己带有一个__proto__指向我们构造函数的原型对象
        console.log(ldh.__proto__===Star.prototype);//true
在这里插入图片描述

constructor构造函数
对象原型(_ proto_ ) 和构造函数( prototype )原型对象里面都有一个属性 constructor属性, constructor我们称为构造函数,因为它指回构造函数本身。

constructor主要用于记录该对象引用于哪个构造函数,它可以让原型对象重新指向原来的构造函数。
在这里插入图片描述

原型链
在这里插入图片描述

JavaScript的成员查找机制(规则)
①当访问一个对象的属性(包括方法)时,首先查找这个对象自身有没有该属性。

②如果没有就查找它的原型(也就是_ proto_ 指向的prototype原型对象)。

③如果还没有就查找原型对象的原型( Object的原型对象)。

④依此类推一直找到Object止( null)。

⑤__proto__对象原型的意 义就在于为对象成员查找机制提供一个向,或者说一条路线。

在原型和构造函数里面this指向的都是实例对象

拓展内置对象
可以通过原型对象，对原来的内置对象进行扩展自定义的方法，比如给数组自定义求和方法sum
注意:数組和字符串内置対象不能原型対象覆盖操作Array.prototype= {} , 只能是Array.prototype.xx = function(){}的方式。
正确：

 Array.prototype.sum=function(){
            var sum=0;
            for(var i=0;i<this.length;i++){
                sum+=this[i];
            }
            return sum;
        }
        var arr=new Array(11,22,33);
    console.log(arr.sum());
错误：

Array.prototype={
        sum:function(){
            var sum=0;
            for(var i=0;i<this.length;i++){
                sum+=this[i];
            }
            return sum;
        }
    }
    var arr=new Array(11,22,33);
    console.log(arr.sum());
JavaScript面向对象tab栏案例
案例需求
1.点击tab栏可以切换效果.

2.点击+号,可以添加tab项和内容项.

3.点击x号,可以删除当前的tab项和内容项

4.双击tab项文字或者内容项文字可以修改里面的文字内容.

分析
抽象对象: Tab对象

1.该对象具有切换功能

2.该对象具有添加功能

3.该对象具有删除功能

4.该对象具有修改功能

面向对象版 tab栏切换切换功能
1.利用for循环给每个li设置索引号
2.给每个li绑定点击事件
3.让当前li显示新类名，其余类清除类名

面向对象版 tab栏切换添加功能
1.点击+可以实现添加新的选项卡和内容

2.第一步:创建新的选项卡i和新的内容section3.第二步: 把创建的两个元素追加到对应的父元素中.

4.以前的做法:动态创建元素createElement , 但是元素里面内容较多，需要innerHTML赋值在appendChild追加到父元素里面.

5.现在高级做法: 利用insertAdjacentHTMLO可以直接把字符串格式元素添加到父元素中6. appendChild不支持追加字符串的子 元素, insertAdjacentHTML 支持追加字符串的元素
element . insertAdjacentHTML (position, text);

position是相对于元素的位置,并且必须是以下字符串之一:

元素自身的前面。

‘afterbegin’

插入元素内部的第一个子节点之前。

‘beforeend’

插入元素内部的最后一个子节点之后。

‘afterend’

元素自身的后面。

text是要被解析为HTML或XML，并插入到DOM树中的字符串。

面向对象版 tab栏切换删除功能
1.点击x可以删除当前的i选项卡和当前的section

2 X是没有索引号的，但是它的父亲li有索引号,这个索引号正是我们想要的索引号

3.所以核心思路是: 点击x号可以删除这个索引号对应的li和section

面向对象版 tab栏切换编辑功能
1.双击选项卡li或者section里面的文字可以实现修改功能
2.双击事件是: ondblclick

3.如果双击文字会默认选定文字此时需要双击禁止选中文字
. window.getSelection ? window.getSelection().removeAllRanges(): document.selection.empty();

4.核心思路:双击文字的时候，在里面生成一个文本框, 当失去焦点或者按下回车然后把文本框输入的值给原先元素即可.

html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <style>
        * {
            margin: 0xp;
            padding: 0px;
            list-style: none;

        }

        h3 {
            margin: 100px 700px;
            width: 400px;
        }

        .warp {
            border: 1px solid red;
            margin: 100px auto;
            width: 600px;
            position: relative;
        }

        .nav {
            width: 100%;
            height: 55px;

        }

        ul li {
            float: left;
            border: 1px solid black;
            width: 100px;
            height: 50px;
            text-align: center;
            line-height: 50px;
        }

        ul {
            position: absolute;
            width: 100%;
            height: 50px;
            top: 0px;
            margin: 0px;
        }

        .jia {
            position: absolute;
            right: 0px;
            top: 0px;
        }

        .content {
            width: 100%;
            height: 100px;
        }

        .active {
            float: left;
            border: 1px solid black;
            border-bottom: none;
            width: 100px;
            height: 50px;
            text-align: center;
            line-height: 50px;
            background-color:pink;
        }

        section {
            width: 100%;
            height: 200px;
            display: none;
            text-align: center;
        }

        .show {
            width: 100%;
            height: 200px;
            display: block;

        }

        .jia {
            border: 1px solid black;
            width: 30px;
            height: 30px;
            text-align: center;
        }
        .del{
            width: 20px;
            height: 20px;
            border: 1px solid red;
            position: absolute;
            top: 0px;
            font-size: 12px;
            line-height: 17px;
            
        }
    </style>
</head>
<body>
    <h3>面向对象tab栏</h3>
    <div class="warp">
        <div class="nav">
            <ul>
                <li class="active">测试1
                    <div class="del">删</div>
                </li>
                <li>测试2
                    <div class="del">删</div>
                </li>
                <li>测试3
                    <div class="del">删</div>
                </li>
            </ul>
            <div class="jia"><span>+</span></div>

        </div>
        <div class="content">
            <section class="show">测试1</section>
            <section>测试2</section>
            <section>测试3</section>
        </div>
    </div>
    <script src="./index.js">
    </script>

</body>

</html>
js
var that;
class Tab {
    constructor(name) {
        that = this;
        this.warp = document.querySelector(name);
        this.add = this.warp.querySelector(".jia");
        this.init();
        //li的父元素
        this.ul = this.warp.querySelector("ul");
        //section的父元素
        this.content = this.warp.querySelector(".content");
    }
    //设置当前li索引号
    init() {
        this.updateNode();
        this.add.onclick = this.addTab;
        for (var i = 0; i < this.lis.length; i++) {
            this.lis[i].index = i;
            this.lis[i].onclick = this.toggleTab//toggleTab不要加括号，不然会立即执行
            this.remove[i].onclick = this.removeTab;
            this.lis[i].ondblclick = this.editTab;


        }
        console.log(this.remove);
    }
    //因为我们动态创建了元素，所以每次必须重新获取对应元素和索引号     
    updateNode() {
        this.lis = this.warp.querySelectorAll("li");
        this.scetions = this.warp.querySelectorAll("section");
        this.remove = this.warp.querySelectorAll(".del");
    }
    //清除其余类名
    clearClass() {
        for (var i = 0; i < this.lis.length; i++) {
            this.lis[i].className = "";
            this.scetions[i].className = ""
        }

    }
    //切换功能
    toggleTab() {
        that.clearClass();
        this.className = "active"//不加点
        that.scetions[this.index].className = "show"
    }

    //添加功能
    addTab() {
        //先清除所有的类
        that.clearClass()
        //创建li,section元素
        var li = ' <li class="active">新选项' + ' <div class="del">删</div>' + " </li>";
        var section = ' <section class="show">新选项卡</section>';
        //追加元素
        that.ul.insertAdjacentHTML("beforeend", li)//相当于appchild
        that.content.insertAdjacentHTML("beforeend", section)//相当于appchild
        that.init()//追加li后重新获取索引号
    }
    //修改功能
    editTab() { 
        var str = this.innerHTML;
        //双击禁止选定文字
        window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty();
        this.innerHTML = '<input type="text" style="width: 70px;">'+' <div class="del">删</div>'
        var input = this.children[0];
        input.value = str;
        input.select();
        input.onblur = function () {
            this.parentNode.innerHTML = this.value;
        }
    }
    //删除功能
    removeTab(e) {
        e.stopPropagation();//阻止点击删除按钮触发li冒泡
        var index = this.parentNode.index;
        //remove()可以直接删除指定元素
        that.lis[index].remove();
        that.scetions[index].remove();
        that.init();

    }


}
new Tab(".warp");
